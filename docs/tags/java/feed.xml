<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Varun Pant</title><link>https://varunpant.com/tags/java/</link><description>Recent content in Java on Varun Pant</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 03 Aug 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://varunpant.com/tags/java/feed.xml" rel="self" type="application/rss+xml"/><item><title>integration testing with apache beam using pubsub and bigtable emulators and direct runner</title><link>https://varunpant.com/posts/integration-testing-with-apache-beam-using-pubsub-and-bigtable-emulators-and-direct-runner/</link><pubDate>Fri, 03 Aug 2018 00:00:00 +0000</pubDate><guid>https://varunpant.com/posts/integration-testing-with-apache-beam-using-pubsub-and-bigtable-emulators-and-direct-runner/</guid><description>
&lt;h3 id="summary"&gt;
Summary
&lt;a href="#summary" class="h-anchor" aria-hidden="true"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Recently I have been looking into ways to test my &lt;strong&gt;Apache Beam&lt;/strong&gt; pipelines at work. Most common use cases of Beam generally involves either batch reading data from GCS and writing to analytical platforms such as Big Query or stream reading data from Pubsub and writing to perhaps Bigtable.&lt;/p&gt;
&lt;p&gt;A pipelines consists of transforms and its generally easy to test them in isolation as a independent unit test per stage, however I am personally a big fan of &amp;ldquo;end-to-end&amp;rdquo; testing or “Integration testing” and this is where things can sometimes get tricky.&lt;/p&gt;</description></item><item><title>Gheat Java – Heat maps</title><link>https://varunpant.com/posts/gheat-java-heat-maps/</link><pubDate>Fri, 24 Jan 2014 00:00:00 +0000</pubDate><guid>https://varunpant.com/posts/gheat-java-heat-maps/</guid><description>
&lt;p&gt;&lt;a href="http://varunpant.com/static/resources/heat_map_2.jpg"&gt;&lt;img src="http://varunpant.com/static/resources/heat_map_thumb.jpg" alt="heat_map" title="heat_map"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;heat map&lt;/strong&gt; is a graphical representation of data where the individual values contained in a &lt;a href="http://en.wikipedia.org/wiki/Matrix_%28mathematics%29"&gt;matrix&lt;/a&gt; are represented as colors.&lt;/p&gt;
&lt;p&gt;This article will attempt to explain the process or creating and using &lt;a href="https://github.com/varunpant/GHEAT-JAVA"&gt;GHEAT-JAVA&lt;/a&gt;, which is a port of famous aspen based &lt;a href="https://code.google.com/p/gheat/"&gt;gheat&lt;/a&gt; and took great inspiration from &lt;a href="http://www.codeproject.com/Articles/88956/GHeat-NET"&gt;Gheat.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Writing a service which would serve heat map tiles is a bit tricky,there are three major components involved&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;The client part i.e. some kind of mapping library which has a concept of layer, I chose Google maps.&lt;/li&gt;
&lt;li&gt;The data source part, i.e. a spatially aware database or an in memory data structure, I have used postgres ,an in memory quad tree and a flat file as data sources.&lt;/li&gt;
&lt;li&gt;The renderer part or basically the code which excepts requests , parses tile bounds, fetches data and then renders gradients on the tile and later colorizes them.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="the-tiling-layer-client-part"&gt;
The Tiling layer (Client part)
&lt;a href="#the-tiling-layer-client-part" class="h-anchor" aria-hidden="true"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Google maps allows developers to add a custom layer , the code looks like this&lt;/p&gt;</description></item></channel></rss>