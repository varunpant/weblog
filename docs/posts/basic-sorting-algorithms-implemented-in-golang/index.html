<!doctype html><html lang=en><head><title>basic sorting algorithms implemented in golang :: Varun Pant — WebLog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="This post includes go-lang based implementation of some of the classic sorting algorithms.
This article primarily, has been written, as an academic exercise, to not forget the basic principles of sorting.
Bubble Sort wiki Bubble sort is perhaps the simplest of all sorting algorithms, the basic principle is to bubble up the largest (or the smallest) and then the second largest and then the third largest and so on. Each bubble takes the full sweep of the list, hence best-case, average-case as well as the worst-case performance are all O(n2)"><meta name=keywords content="Cloud,maps,GIS,Google Cloud,Google Maps,Openlayer,Javascript,go,Hadoop,BigData,Spark"><meta name=robots content="noodp"><link rel=canonical href=https://varunpant.com/posts/basic-sorting-algorithms-implemented-in-golang/><link type=application/opensearchdescription+xml rel=search title="Varun Pant" href=//www.varunpant.com/opensearch.axd><link rel=me type=text/html href="//plus.google.com/108455320594011020517?rel=me"><link rel=me type=text/html href=//varunpant.com/feed><link rel=me type=text/html href=//twitter.com/varunpant><link rel=me type=text/html href=//www.facebook.com/varun.pant><meta name=msvalidate.01 content="B96ED99B0213B547253C91D27272A5E4"><meta name=google-site-verification content="yu9tlev9-FkUUc0UkPrKP-8ren886--1FcSINU0TJDY"><meta http-equiv=x-xrds-location content="//www.myopenid.com/xrds?username=varunpant.myopenid.com"><meta name=syndication content="//feeds.feedburner.com/varun.pant"><link rel=stylesheet href=https://varunpant.com/assets/style.css><link rel=stylesheet href=https://varunpant.com/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://varunpant.com/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://varunpant.com/img/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:title content="basic sorting algorithms implemented in golang"><meta name=twitter:description content="This post includes go-lang based implementation of some of the classic sorting algorithms.
This article primarily, has been written, as an academic exercise, to not forget the basic principles of sorting.
Bubble Sort wiki Bubble sort is perhaps the simplest of all sorting algorithms, the basic principle is to bubble up the largest (or the smallest) and then the second largest and then the third largest and so on. Each bubble takes the full sweep of the list, hence best-case, average-case as well as the worst-case performance are all O(n2)"><meta property="og:title" content="basic sorting algorithms implemented in golang"><meta property="og:description" content="This post includes go-lang based implementation of some of the classic sorting algorithms.
This article primarily, has been written, as an academic exercise, to not forget the basic principles of sorting.
Bubble Sort wiki Bubble sort is perhaps the simplest of all sorting algorithms, the basic principle is to bubble up the largest (or the smallest) and then the second largest and then the third largest and so on. Each bubble takes the full sweep of the list, hence best-case, average-case as well as the worst-case performance are all O(n2)"><meta property="og:type" content="article"><meta property="og:url" content="https://varunpant.com/posts/basic-sorting-algorithms-implemented-in-golang/"><meta property="article:published_time" content="2017-09-04T00:00:00+00:00"><meta property="article:modified_time" content="2017-09-04T00:00:00+00:00"><meta property="og:site_name" content="Varun Pant"><section><div id=ta class=advert><script type=text/javascript>google_ad_client="ca-pub-1110730152886910";google_ad_slot="7384719372";google_ad_width=468;google_ad_height=60;</script><script type=text/javascript src=//pagead2.googlesyndication.com/pagead/show_ads.js></script></div></section></head><body><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Varun Pant</span>
<span class=logo__cursor></span></a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/archives>Archives</a></li><li><a href=/feed.xml>Feed</a></li><li><a href=/showcase>Showcase</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/archives>Archives</a></li><li><a href=/feed.xml>Feed</a></li><li><a href=/showcase>Showcase</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41C32.4934 41 41 32.4934 41 22 41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h2 class=post-title><a href=https://varunpant.com/posts/basic-sorting-algorithms-implemented-in-golang/>basic sorting algorithms implemented in golang</a></h2><div class=post-meta><span class=post-date>2017-09-04</span>
<span class=post-author>— Varun Pant</span>
<span class=post-read-time>— 4 min read</span></div><div class=post-content><p>This post includes go-lang based implementation of some of the classic sorting algorithms.</p><p>This article primarily, has been written, as an academic exercise, to not forget the basic principles of sorting.</p><h3 id=bubble-sort>Bubble Sort</h3><p><a href=http://en.wikipedia.org/wiki/Bubble_sort>wiki</a> <img src=https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif alt></p><p>Bubble sort is perhaps the simplest of all sorting algorithms, the basic principle is to bubble up the largest (or the smallest) and then the second largest and then the third largest and so on. Each bubble takes the full sweep of the list, hence best-case, average-case as well as the worst-case performance are all O(n2)</p><pre><code class=language-package data-lang=package>
func BubbleSort( items []int) {  
  
 L:=len(items)  
  
 for i:=0;i&lt;L;i++{  
  
 for j:=0;j&lt; (L-1-i);j++{  
 if items[j] &gt; items[j+1]{  
 items[j], items[j+1] = items[j+1], items[j]  
 }  
 }  
 }  
  
} 
</code></pre><h3 id=insertion-sort>Insertion Sort</h3><p><a href=https://en.wikipedia.org/wiki/Insertion_sort>wiki</a> <img src=https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif alt></p><p>Insertion sort takes each element through the list and inserts it at the right place. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Worst-case and average-case performance is O(n2), however the best case is O(n).</p><pre><code class=language-package data-lang=package>
func InsertionSort(items []int) {  
  
   L := len(items)  
  
   for i := 1; i &lt; L; i++ {  
  
      j := i  
      for j &gt; 0 &amp;&amp; items[j] &lt; items[j-1] {  
         items[j], items[j-1] = items[j-1], items[j]  
         j -= 1  
      }  
  
   }  
  
}

</code></pre><h3 id=merge-sort>Merge Sort</h3><p><a href=https://en.wikipedia.org/wiki/Merge_sort>wiki</a> <img src=https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif alt></p><p>Mergesort operates by diving the list into two sublist recursively till each sublist contains only one element, it then merges the adjacent list back while sorting each element in the merged list. Best-case, average-case as well as the worst-case eprformance are all O(nlogn)</p><pre><code class=language-package data-lang=package>  
const NADA int = -1  
  
func DeepCopy(vals []int) []int {  
   tmp := make([]int, len(vals))  
   copy(tmp, vals)  
   return tmp  
}  
  
func MergeSort(items []int) {  
  
   if len(items) &gt; 1 {  
      mid := len(items) / 2  
      left := DeepCopy(items[0:mid])  
      right := DeepCopy(items[mid:])  
  
      MergeSort(left)  
      MergeSort(right)  
  
      l := 0  
      r := 0  
  
      for i := 0; i &lt; len(items); i++ {  
  
         lval := NADA  
         rval := NADA  
  
         if l &lt; len(left) {  
            lval = left[l]  
         }  
  
         if r &lt; len(right) {  
            rval = right[r]  
         }  
  
         if (lval != NADA &amp;&amp; rval != NADA &amp;&amp; lval &lt; rval) || rval == NADA {  
            items[i] = lval  
            l += 1  
         } else if (lval != NADA &amp;&amp; rval != NADA &amp;&amp; lval &gt;= rval) || lval == NADA {  
            items[i] = rval  
            r += 1  
         }  
  
      }  
   }  
  
}  



</code></pre><h3 id=quicksort-sort>Quicksort Sort</h3><p><a href=https://en.wikipedia.org/wiki/Quicksort>wiki</a></p><p><img src=https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif alt></p><p>Quick sort works by first selecting a pivot element from the list. It then creates two lists, one containing elements less than the pivot and the other containing elements higher than the pivot. It then sorts the two lists and join them with the pivot in between. Just like the Merge sort, when the lists are subdivided to lists of size 1, they are considered as already sorted. Best-case and avergae-case is O(n log n) however the worstcase(very rare) is O(n2)</p><pre><code class=language-func data-lang=func>  
   if len(items) &gt; 1 {  
      pivot\_index := len(items) / 2  
      var smaller\_items = []int{}  
      var larger\_items = []int{}  
  
      for i := range items {  
         val := items[i]  
         if i != pivot\_index {  
            if val &lt; items[pivot\_index] {  
               smaller\_items = append(smaller\_items, val)  
            } else {  
               larger\_items = append(larger\_items, val)  
            }  
         }  
      }  
  
      QuickSort(smaller\_items)  
      QuickSort(larger\_items)  
  
      var merged []int = append(append(append([]int{}, smaller\_items...), []int{items[pivot\_index]}...), larger\_items...)  
      //merged := MergeLists(smaller\_items, items[pivot\_index], larger\_items)  
  
      for j := 0; j &lt; len(items); j++ {  
         items[j] = merged[j]  
      }  
  
   }  
  
}  


</code></pre><h3 id=heap-sort>Heap Sort</h3><p><a href=http://en.wikipedia.org/wiki/Heapsort>wiki</a></p><p><img src=https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif alt></p><p>Heapsort can be thought of as an improved selection sort: like that algorithm, it divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. The improvement consists of the use of a heap data structure rather than a linear-time search to find the maximum,best-case, average-case as well as the worst-caseeprformance are all O(nlogn)</p><pre><code class=language-package data-lang=package>
  
func heapify(items []int, idx int, size int) {  
   l := 2*idx + 1 // left = 2*i + 1  
   r := 2*idx + 2 // right = 2*i + 2  
  
   var largest int;  
   if l &lt;= size &amp;&amp; items[l] &gt; items[idx] {  
      largest = l  
   } else {  
      largest = idx  
   }  
  
   if r &lt;= size &amp;&amp; items[r] &gt; items[largest] {  
      largest = r  
   }  
  
   if largest != idx {  
      t := items[idx]  
      items[idx] = items[largest]  
      items[largest] = t  
      heapify(items, largest, size)  
   }  
  
}  
  
func HeapSort(items []int) {  
  
   L := len(items) //heap size  
   m := int(L / 2) //middle  
  
   for i := m; i &gt;= 0; i-- {  
  
      heapify(items, i, L-1)  
   }  
  
   F := L - 1  
   for j := F; j &gt;= 0; j-- {  
      t := items[0]  
      items[0] = items[j]  
      items[j] = t  
      F -= 1  
      heapify(items, 0, F)  
   }  
  
}  


</code></pre><p>Finally to run these algos I have written a quick main program</p><pre><code class=language-import data-lang=import>  &quot;fmt&quot;
  &quot;time&quot;
  &quot;math/rand&quot;
)

func main() {

  fmt.Println(&quot;Preparing!&quot;)
  var randomVals = []int{}
  s1 := rand.NewSource(time.Now().UnixNano())
  r1 := rand.New(s1)
  for i := 0; i &lt; 11; i++ {
    randomVals = append(randomVals, r1.Intn(99)+1)
  }

  fmt.Println(&quot;Unsorted!&quot;)
  fmt.Println(randomVals)
  //BubbleSortrandomVals()
  //InsertionSort(randomVals)
  //MergeSort(randomVals)
  //QuickSort(randomVals)
  HeapSort(randomVals)

  fmt.Println(&quot;sorted!&quot;)
  fmt.Println(randomVals)
}
</code></pre><pre><code class=language-finally data-lang=finally></code></pre></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://varunpant.com/posts/inverse-weighted-distance-interpolation-in-golang/><span class=button__icon>←</span>
<span class=button__text>Inverse weighted distance interpolation in golang</span></a></span>
<span class="button next"><a href=https://varunpant.com/posts/reading-and-writing-binary-files-in-go-lang/><span class=button__text>reading and writing binary files in go lang</span>
<span class=button__icon>→</span></a></span></div></div><div id=blog-comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"varunpant"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Varun Pant</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2019 Powered by <a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by <a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=https://varunpant.com/assets/main.js></script><script src=https://varunpant.com/assets/prism.js></script><section><div class=advert id=ta2><script type=text/javascript>google_ad_client="ca-pub-1110730152886910";google_ad_slot="1639236970";google_ad_width=728;google_ad_height=90;</script><script type=text/javascript src=//pagead2.googlesyndication.com/pagead/show_ads.js></script></div></section></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-16978408-1','auto');ga('send','pageview');}</script></body></html>